Grading at Mon Jul  8 20:33:03 UTC 2019
Compiling your code
rm -f test poker cards.o my-test-main.o *~
cc -ggdb3 -Wall -Werror -pedantic -std=gnu99   -c -o deck.o deck.c
cc -ggdb3 -Wall -Werror -pedantic -std=gnu99   -c -o eval.o eval.c
cc -ggdb3 -Wall -Werror -pedantic -std=gnu99   -c -o cards.o cards.c
gcc -o test-eval -ggdb3 deck.o deck-c4.o eval-c4.o eval.o test-eval.o cards.o input.o future.o
Testcase 1: Trying hands with nothing
Valgrind returned an error status
==1476== Memcheck, a memory error detector
==1476== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1476== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1476== Command: ./test-eval inp.1.txt
==1476== Parent PID: 1475
==1476== 
==1476== Use of uninitialised value of size 8
==1476==    at 0x400C02: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402D10: suit_letter (cards.c:67)
==1476==    by 0x402D56: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402C45: value_letter (cards.c:38)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402C57: value_letter (cards.c:40)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402C69: value_letter (cards.c:42)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402C7B: value_letter (cards.c:44)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402C8A: value_letter (cards.c:46)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402C99: value_letter (cards.c:48)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402CA8: value_letter (cards.c:50)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402CB7: value_letter (cards.c:52)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402CC6: value_letter (cards.c:54)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402CD5: value_letter (cards.c:56)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402CE4: value_letter (cards.c:58)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Conditional jump or move depends on uninitialised value(s)
==1476==    at 0x402CF3: value_letter (cards.c:60)
==1476==    by 0x402D65: print_card (cards.c:79)
==1476==    by 0x400C09: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476== 
==1476== Invalid read of size 8
==1476==    at 0x400C02: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476==  Address 0x400001102 is not stack'd, malloc'd or (recently) free'd
==1476== 
==1476== 
==1476== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1476==  Access not within mapped region at address 0x400001102
==1476==    at 0x400C02: print_hand (deck.c:7)
==1476==    by 0x402864: describe_hand (test-eval.c:74)
==1476==    by 0x402A44: main (test-eval.c:116)
==1476==  If you believe this happened as a result of a stack
==1476==  overflow in your program's main thread (unlikely but
==1476==  possible), you can try to increase the size of the
==1476==  main thread stack using the --main-stacksize= flag.
==1476==  The main thread stack size used in this run was 8388608.
==1476== 
==1476== HEAP SUMMARY:
==1476==     in use at exit: 896 bytes in 18 blocks
==1476==   total heap usage: 32 allocs, 14 frees, 9,376 bytes allocated
==1476== 
==1476== LEAK SUMMARY:
==1476==    definitely lost: 0 bytes in 0 blocks
==1476==    indirectly lost: 0 bytes in 0 blocks
==1476==      possibly lost: 0 bytes in 0 blocks
==1476==    still reachable: 896 bytes in 18 blocks
==1476==         suppressed: 0 bytes in 0 blocks
==1476== Rerun with --leak-check=full to see details of leaked memory
==1476== 
==1476== For counts of detected and suppressed errors, rerun with: -v
==1476== Use --track-origins=yes to see where uninitialised values come from
==1476== ERROR SUMMARY: 16 errors from 15 contexts (suppressed: 0 from 0)
Testcase 2: Trying hands with pairs
Valgrind returned an error status
==1481== Memcheck, a memory error detector
==1481== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1481== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1481== Command: ./test-eval inp.2.txt
==1481== Parent PID: 1480
==1481== 
==1481== Use of uninitialised value of size 8
==1481==    at 0x400C02: print_hand (deck.c:7)
==1481==    by 0x402864: describe_hand (test-eval.c:74)
==1481==    by 0x402A64: main (test-eval.c:119)
==1481== 
==1481== Invalid read of size 8
==1481==    at 0x400C02: print_hand (deck.c:7)
==1481==    by 0x402864: describe_hand (test-eval.c:74)
==1481==    by 0x402A64: main (test-eval.c:119)
==1481==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1481== 
==1481== 
==1481== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1481==  Access not within mapped region at address 0x0
==1481==    at 0x400C02: print_hand (deck.c:7)
==1481==    by 0x402864: describe_hand (test-eval.c:74)
==1481==    by 0x402A64: main (test-eval.c:119)
==1481==  If you believe this happened as a result of a stack
==1481==  overflow in your program's main thread (unlikely but
==1481==  possible), you can try to increase the size of the
==1481==  main thread stack using the --main-stacksize= flag.
==1481==  The main thread stack size used in this run was 8388608.
==1481== 
==1481== HEAP SUMMARY:
==1481==     in use at exit: 896 bytes in 18 blocks
==1481==   total heap usage: 146 allocs, 128 frees, 11,444 bytes allocated
==1481== 
==1481== LEAK SUMMARY:
==1481==    definitely lost: 0 bytes in 0 blocks
==1481==    indirectly lost: 0 bytes in 0 blocks
==1481==      possibly lost: 0 bytes in 0 blocks
==1481==    still reachable: 896 bytes in 18 blocks
==1481==         suppressed: 0 bytes in 0 blocks
==1481== Rerun with --leak-check=full to see details of leaked memory
==1481== 
==1481== For counts of detected and suppressed errors, rerun with: -v
==1481== Use --track-origins=yes to see where uninitialised values come from
==1481== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
Testcase 3: Trying hands with 2 pairs
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 4: Trying hands with 3 of a kind
Valgrind returned an error status
==1498== Memcheck, a memory error detector
==1498== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1498== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1498== Command: ./test-eval inp.4.txt
==1498== Parent PID: 1497
==1498== 
==1498== Use of uninitialised value of size 8
==1498==    at 0x400C02: print_hand (deck.c:7)
==1498==    by 0x402864: describe_hand (test-eval.c:74)
==1498==    by 0x402A44: main (test-eval.c:116)
==1498== 
==1498== Invalid read of size 8
==1498==    at 0x400C02: print_hand (deck.c:7)
==1498==    by 0x402864: describe_hand (test-eval.c:74)
==1498==    by 0x402A44: main (test-eval.c:116)
==1498==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1498== 
==1498== 
==1498== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1498==  Access not within mapped region at address 0x0
==1498==    at 0x400C02: print_hand (deck.c:7)
==1498==    by 0x402864: describe_hand (test-eval.c:74)
==1498==    by 0x402A44: main (test-eval.c:116)
==1498==  If you believe this happened as a result of a stack
==1498==  overflow in your program's main thread (unlikely but
==1498==  possible), you can try to increase the size of the
==1498==  main thread stack using the --main-stacksize= flag.
==1498==  The main thread stack size used in this run was 8388608.
==1498== 
==1498== HEAP SUMMARY:
==1498==     in use at exit: 896 bytes in 18 blocks
==1498==   total heap usage: 264 allocs, 246 frees, 13,664 bytes allocated
==1498== 
==1498== LEAK SUMMARY:
==1498==    definitely lost: 0 bytes in 0 blocks
==1498==    indirectly lost: 0 bytes in 0 blocks
==1498==      possibly lost: 0 bytes in 0 blocks
==1498==    still reachable: 896 bytes in 18 blocks
==1498==         suppressed: 0 bytes in 0 blocks
==1498== Rerun with --leak-check=full to see details of leaked memory
==1498== 
==1498== For counts of detected and suppressed errors, rerun with: -v
==1498== Use --track-origins=yes to see where uninitialised values come from
==1498== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
Testcase 5: Trying hands with straights
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 6: Trying hands with flushes
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 7: Trying hands with full houses
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 8: Trying hands with 4 of a kind
Valgrind returned an error status
==1539== Memcheck, a memory error detector
==1539== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1539== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1539== Command: ./test-eval inp.8.txt
==1539== Parent PID: 1538
==1539== 
==1539== Use of uninitialised value of size 8
==1539==    at 0x400C02: print_hand (deck.c:7)
==1539==    by 0x402864: describe_hand (test-eval.c:74)
==1539==    by 0x402A64: main (test-eval.c:119)
==1539== 
==1539== Invalid read of size 8
==1539==    at 0x400C02: print_hand (deck.c:7)
==1539==    by 0x402864: describe_hand (test-eval.c:74)
==1539==    by 0x402A64: main (test-eval.c:119)
==1539==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1539== 
==1539== 
==1539== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1539==  Access not within mapped region at address 0x0
==1539==    at 0x400C02: print_hand (deck.c:7)
==1539==    by 0x402864: describe_hand (test-eval.c:74)
==1539==    by 0x402A64: main (test-eval.c:119)
==1539==  If you believe this happened as a result of a stack
==1539==  overflow in your program's main thread (unlikely but
==1539==  possible), you can try to increase the size of the
==1539==  main thread stack using the --main-stacksize= flag.
==1539==  The main thread stack size used in this run was 8388608.
==1539== 
==1539== HEAP SUMMARY:
==1539==     in use at exit: 896 bytes in 18 blocks
==1539==   total heap usage: 208 allocs, 190 frees, 12,640 bytes allocated
==1539== 
==1539== LEAK SUMMARY:
==1539==    definitely lost: 0 bytes in 0 blocks
==1539==    indirectly lost: 0 bytes in 0 blocks
==1539==      possibly lost: 0 bytes in 0 blocks
==1539==    still reachable: 896 bytes in 18 blocks
==1539==         suppressed: 0 bytes in 0 blocks
==1539== Rerun with --leak-check=full to see details of leaked memory
==1539== 
==1539== For counts of detected and suppressed errors, rerun with: -v
==1539== Use --track-origins=yes to see where uninitialised values come from
==1539== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
Testcase 9: Trying hands with straight flushes
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 10: Trying each type of hand ranking
Valgrind returned an error status
==1556== Memcheck, a memory error detector
==1556== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1556== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1556== Command: ./test-eval inp.10.txt
==1556== Parent PID: 1555
==1556== 
==1556== Use of uninitialised value of size 8
==1556==    at 0x400C02: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402D10: suit_letter (cards.c:67)
==1556==    by 0x402D56: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402C45: value_letter (cards.c:38)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402C57: value_letter (cards.c:40)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402C69: value_letter (cards.c:42)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402C7B: value_letter (cards.c:44)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402C8A: value_letter (cards.c:46)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402C99: value_letter (cards.c:48)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402CA8: value_letter (cards.c:50)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402CB7: value_letter (cards.c:52)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402CC6: value_letter (cards.c:54)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402CD5: value_letter (cards.c:56)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402CE4: value_letter (cards.c:58)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Conditional jump or move depends on uninitialised value(s)
==1556==    at 0x402CF3: value_letter (cards.c:60)
==1556==    by 0x402D65: print_card (cards.c:79)
==1556==    by 0x400C09: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556== 
==1556== Invalid read of size 8
==1556==    at 0x400C02: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556==  Address 0x400001102 is not stack'd, malloc'd or (recently) free'd
==1556== 
==1556== 
==1556== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1556==  Access not within mapped region at address 0x400001102
==1556==    at 0x400C02: print_hand (deck.c:7)
==1556==    by 0x402864: describe_hand (test-eval.c:74)
==1556==    by 0x402A64: main (test-eval.c:119)
==1556==  If you believe this happened as a result of a stack
==1556==  overflow in your program's main thread (unlikely but
==1556==  possible), you can try to increase the size of the
==1556==  main thread stack using the --main-stacksize= flag.
==1556==  The main thread stack size used in this run was 8388608.
==1556== 
==1556== HEAP SUMMARY:
==1556==     in use at exit: 896 bytes in 18 blocks
==1556==   total heap usage: 154 allocs, 136 frees, 11,708 bytes allocated
==1556== 
==1556== LEAK SUMMARY:
==1556==    definitely lost: 0 bytes in 0 blocks
==1556==    indirectly lost: 0 bytes in 0 blocks
==1556==      possibly lost: 0 bytes in 0 blocks
==1556==    still reachable: 896 bytes in 18 blocks
==1556==         suppressed: 0 bytes in 0 blocks
==1556== Rerun with --leak-check=full to see details of leaked memory
==1556== 
==1556== For counts of detected and suppressed errors, rerun with: -v
==1556== Use --track-origins=yes to see where uninitialised values come from
==1556== ERROR SUMMARY: 16 errors from 15 contexts (suppressed: 0 from 0)

Overall Grade: F
