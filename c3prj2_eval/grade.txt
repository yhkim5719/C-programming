Grading at Mon Jul  8 20:54:11 UTC 2019
Compiling your code
rm -f test poker cards.o my-test-main.o *~
cc -ggdb3 -Wall -Werror -pedantic -std=gnu99   -c -o deck.o deck.c
cc -ggdb3 -Wall -Werror -pedantic -std=gnu99   -c -o eval.o eval.c
cc -ggdb3 -Wall -Werror -pedantic -std=gnu99   -c -o cards.o cards.c
gcc -o test-eval -ggdb3 deck.o deck-c4.o eval-c4.o eval.o test-eval.o cards.o input.o future.o
Testcase 1: Trying hands with nothing
Valgrind returned an error status
==1913== Memcheck, a memory error detector
==1913== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1913== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1913== Command: ./test-eval inp.1.txt
==1913== Parent PID: 1912
==1913== 
==1913== Use of uninitialised value of size 8
==1913==    at 0x400C02: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402D10: suit_letter (cards.c:67)
==1913==    by 0x402D56: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402C45: value_letter (cards.c:38)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402C57: value_letter (cards.c:40)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402C69: value_letter (cards.c:42)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402C7B: value_letter (cards.c:44)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402C8A: value_letter (cards.c:46)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402C99: value_letter (cards.c:48)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402CA8: value_letter (cards.c:50)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402CB7: value_letter (cards.c:52)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402CC6: value_letter (cards.c:54)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402CD5: value_letter (cards.c:56)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402CE4: value_letter (cards.c:58)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Conditional jump or move depends on uninitialised value(s)
==1913==    at 0x402CF3: value_letter (cards.c:60)
==1913==    by 0x402D65: print_card (cards.c:79)
==1913==    by 0x400C09: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913== 
==1913== Invalid read of size 8
==1913==    at 0x400C02: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913==  Address 0x400001102 is not stack'd, malloc'd or (recently) free'd
==1913== 
==1913== 
==1913== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1913==  Access not within mapped region at address 0x400001102
==1913==    at 0x400C02: print_hand (deck.c:7)
==1913==    by 0x402864: describe_hand (test-eval.c:74)
==1913==    by 0x402A44: main (test-eval.c:116)
==1913==  If you believe this happened as a result of a stack
==1913==  overflow in your program's main thread (unlikely but
==1913==  possible), you can try to increase the size of the
==1913==  main thread stack using the --main-stacksize= flag.
==1913==  The main thread stack size used in this run was 8388608.
==1913== 
==1913== HEAP SUMMARY:
==1913==     in use at exit: 896 bytes in 18 blocks
==1913==   total heap usage: 32 allocs, 14 frees, 9,376 bytes allocated
==1913== 
==1913== LEAK SUMMARY:
==1913==    definitely lost: 0 bytes in 0 blocks
==1913==    indirectly lost: 0 bytes in 0 blocks
==1913==      possibly lost: 0 bytes in 0 blocks
==1913==    still reachable: 896 bytes in 18 blocks
==1913==         suppressed: 0 bytes in 0 blocks
==1913== Rerun with --leak-check=full to see details of leaked memory
==1913== 
==1913== For counts of detected and suppressed errors, rerun with: -v
==1913== Use --track-origins=yes to see where uninitialised values come from
==1913== ERROR SUMMARY: 16 errors from 15 contexts (suppressed: 0 from 0)
Testcase 2: Trying hands with pairs
Valgrind returned an error status
==1918== Memcheck, a memory error detector
==1918== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1918== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1918== Command: ./test-eval inp.2.txt
==1918== Parent PID: 1917
==1918== 
==1918== Use of uninitialised value of size 8
==1918==    at 0x400C02: print_hand (deck.c:7)
==1918==    by 0x402864: describe_hand (test-eval.c:74)
==1918==    by 0x402A64: main (test-eval.c:119)
==1918== 
==1918== Invalid read of size 8
==1918==    at 0x400C02: print_hand (deck.c:7)
==1918==    by 0x402864: describe_hand (test-eval.c:74)
==1918==    by 0x402A64: main (test-eval.c:119)
==1918==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1918== 
==1918== 
==1918== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1918==  Access not within mapped region at address 0x0
==1918==    at 0x400C02: print_hand (deck.c:7)
==1918==    by 0x402864: describe_hand (test-eval.c:74)
==1918==    by 0x402A64: main (test-eval.c:119)
==1918==  If you believe this happened as a result of a stack
==1918==  overflow in your program's main thread (unlikely but
==1918==  possible), you can try to increase the size of the
==1918==  main thread stack using the --main-stacksize= flag.
==1918==  The main thread stack size used in this run was 8388608.
==1918== 
==1918== HEAP SUMMARY:
==1918==     in use at exit: 896 bytes in 18 blocks
==1918==   total heap usage: 146 allocs, 128 frees, 11,444 bytes allocated
==1918== 
==1918== LEAK SUMMARY:
==1918==    definitely lost: 0 bytes in 0 blocks
==1918==    indirectly lost: 0 bytes in 0 blocks
==1918==      possibly lost: 0 bytes in 0 blocks
==1918==    still reachable: 896 bytes in 18 blocks
==1918==         suppressed: 0 bytes in 0 blocks
==1918== Rerun with --leak-check=full to see details of leaked memory
==1918== 
==1918== For counts of detected and suppressed errors, rerun with: -v
==1918== Use --track-origins=yes to see where uninitialised values come from
==1918== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
Testcase 3: Trying hands with 2 pairs
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 4: Trying hands with 3 of a kind
Valgrind returned an error status
==1935== Memcheck, a memory error detector
==1935== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1935== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1935== Command: ./test-eval inp.4.txt
==1935== Parent PID: 1934
==1935== 
==1935== Use of uninitialised value of size 8
==1935==    at 0x400C02: print_hand (deck.c:7)
==1935==    by 0x402864: describe_hand (test-eval.c:74)
==1935==    by 0x402A44: main (test-eval.c:116)
==1935== 
==1935== Invalid read of size 8
==1935==    at 0x400C02: print_hand (deck.c:7)
==1935==    by 0x402864: describe_hand (test-eval.c:74)
==1935==    by 0x402A44: main (test-eval.c:116)
==1935==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1935== 
==1935== 
==1935== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1935==  Access not within mapped region at address 0x0
==1935==    at 0x400C02: print_hand (deck.c:7)
==1935==    by 0x402864: describe_hand (test-eval.c:74)
==1935==    by 0x402A44: main (test-eval.c:116)
==1935==  If you believe this happened as a result of a stack
==1935==  overflow in your program's main thread (unlikely but
==1935==  possible), you can try to increase the size of the
==1935==  main thread stack using the --main-stacksize= flag.
==1935==  The main thread stack size used in this run was 8388608.
==1935== 
==1935== HEAP SUMMARY:
==1935==     in use at exit: 896 bytes in 18 blocks
==1935==   total heap usage: 264 allocs, 246 frees, 13,664 bytes allocated
==1935== 
==1935== LEAK SUMMARY:
==1935==    definitely lost: 0 bytes in 0 blocks
==1935==    indirectly lost: 0 bytes in 0 blocks
==1935==      possibly lost: 0 bytes in 0 blocks
==1935==    still reachable: 896 bytes in 18 blocks
==1935==         suppressed: 0 bytes in 0 blocks
==1935== Rerun with --leak-check=full to see details of leaked memory
==1935== 
==1935== For counts of detected and suppressed errors, rerun with: -v
==1935== Use --track-origins=yes to see where uninitialised values come from
==1935== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
Testcase 5: Trying hands with straights
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 6: Trying hands with flushes
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 7: Trying hands with full houses
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 8: Trying hands with 4 of a kind
Valgrind returned an error status
==1976== Memcheck, a memory error detector
==1976== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1976== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1976== Command: ./test-eval inp.8.txt
==1976== Parent PID: 1975
==1976== 
==1976== Use of uninitialised value of size 8
==1976==    at 0x400C02: print_hand (deck.c:7)
==1976==    by 0x402864: describe_hand (test-eval.c:74)
==1976==    by 0x402A64: main (test-eval.c:119)
==1976== 
==1976== Invalid read of size 8
==1976==    at 0x400C02: print_hand (deck.c:7)
==1976==    by 0x402864: describe_hand (test-eval.c:74)
==1976==    by 0x402A64: main (test-eval.c:119)
==1976==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1976== 
==1976== 
==1976== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1976==  Access not within mapped region at address 0x0
==1976==    at 0x400C02: print_hand (deck.c:7)
==1976==    by 0x402864: describe_hand (test-eval.c:74)
==1976==    by 0x402A64: main (test-eval.c:119)
==1976==  If you believe this happened as a result of a stack
==1976==  overflow in your program's main thread (unlikely but
==1976==  possible), you can try to increase the size of the
==1976==  main thread stack using the --main-stacksize= flag.
==1976==  The main thread stack size used in this run was 8388608.
==1976== 
==1976== HEAP SUMMARY:
==1976==     in use at exit: 896 bytes in 18 blocks
==1976==   total heap usage: 208 allocs, 190 frees, 12,640 bytes allocated
==1976== 
==1976== LEAK SUMMARY:
==1976==    definitely lost: 0 bytes in 0 blocks
==1976==    indirectly lost: 0 bytes in 0 blocks
==1976==      possibly lost: 0 bytes in 0 blocks
==1976==    still reachable: 896 bytes in 18 blocks
==1976==         suppressed: 0 bytes in 0 blocks
==1976== Rerun with --leak-check=full to see details of leaked memory
==1976== 
==1976== For counts of detected and suppressed errors, rerun with: -v
==1976== Use --track-origins=yes to see where uninitialised values come from
==1976== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
Testcase 9: Trying hands with straight flushes
 Checking the output 
Your file matched the expected output
 - Testcase passed
Testcase 10: Trying each type of hand ranking
Valgrind returned an error status
==1993== Memcheck, a memory error detector
==1993== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==1993== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==1993== Command: ./test-eval inp.10.txt
==1993== Parent PID: 1992
==1993== 
==1993== Use of uninitialised value of size 8
==1993==    at 0x400C02: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402D10: suit_letter (cards.c:67)
==1993==    by 0x402D56: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402C45: value_letter (cards.c:38)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402C57: value_letter (cards.c:40)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402C69: value_letter (cards.c:42)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402C7B: value_letter (cards.c:44)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402C8A: value_letter (cards.c:46)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402C99: value_letter (cards.c:48)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402CA8: value_letter (cards.c:50)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402CB7: value_letter (cards.c:52)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402CC6: value_letter (cards.c:54)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402CD5: value_letter (cards.c:56)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402CE4: value_letter (cards.c:58)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Conditional jump or move depends on uninitialised value(s)
==1993==    at 0x402CF3: value_letter (cards.c:60)
==1993==    by 0x402D65: print_card (cards.c:79)
==1993==    by 0x400C09: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993== 
==1993== Invalid read of size 8
==1993==    at 0x400C02: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993==  Address 0x400001102 is not stack'd, malloc'd or (recently) free'd
==1993== 
==1993== 
==1993== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==1993==  Access not within mapped region at address 0x400001102
==1993==    at 0x400C02: print_hand (deck.c:7)
==1993==    by 0x402864: describe_hand (test-eval.c:74)
==1993==    by 0x402A64: main (test-eval.c:119)
==1993==  If you believe this happened as a result of a stack
==1993==  overflow in your program's main thread (unlikely but
==1993==  possible), you can try to increase the size of the
==1993==  main thread stack using the --main-stacksize= flag.
==1993==  The main thread stack size used in this run was 8388608.
==1993== 
==1993== HEAP SUMMARY:
==1993==     in use at exit: 896 bytes in 18 blocks
==1993==   total heap usage: 154 allocs, 136 frees, 11,708 bytes allocated
==1993== 
==1993== LEAK SUMMARY:
==1993==    definitely lost: 0 bytes in 0 blocks
==1993==    indirectly lost: 0 bytes in 0 blocks
==1993==      possibly lost: 0 bytes in 0 blocks
==1993==    still reachable: 896 bytes in 18 blocks
==1993==         suppressed: 0 bytes in 0 blocks
==1993== Rerun with --leak-check=full to see details of leaked memory
==1993== 
==1993== For counts of detected and suppressed errors, rerun with: -v
==1993== Use --track-origins=yes to see where uninitialised values come from
==1993== ERROR SUMMARY: 16 errors from 15 contexts (suppressed: 0 from 0)

Overall Grade: F
